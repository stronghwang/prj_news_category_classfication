# -*- coding: utf-8 -*-
"""exam26_predict_daily_stock_price

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oEJBFA8E-0WIVeeNyTvUBVz-fzuNe3dv

# 주가 예측 모델(RNN 활용)
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import *
from tensorflow.keras.optimizers import Adam

raw_data = pd.read_csv('/content/datasets/samsung.csv')
print(raw_data.head())

# 결측치 확인
print(raw_data.info())
print(raw_data.isnull().sum())

# 결측치 제거
raw_data.dropna(inplace=True)
raw_data.reset_index(drop=True, inplace=True)
print(raw_data)

raw_data.isnull().sum()

data_close = raw_data[['Close']]
print(data_close.head())

data_close = data_close.sort_values('Close')
print(data_close.head())
print(data_close.tail())

# datetime 타입으로 변경 (확인 용도)
raw_data['Date'] = pd.to_datetime(raw_data['Date'])
raw_data.set_index('Date', inplace=True)
print(raw_data.head())

raw_data['Close'].plot()
plt.show()

data = raw_data[:'2021-10-09'][['Close']]
print(data.head())
print(data.tail())
print(data.info())

data.plot()

from sklearn.preprocessing import MinMaxScaler
minmaxscaler = MinMaxScaler()
scaled_data = minmaxscaler.fit_transform(data)
print(scaled_data[:5])
print(scaled_data.shape)

sequence_X = []
sequence_Y = []
for i in range(len(scaled_data)-30):
    x = scaled_data[i:i+30]
    y = scaled_data[i+30]
    sequence_X.append(x)
    sequence_Y.append(y)
    if i is 0:
        print(x, '->', y)

sequence_X = np.array(sequence_X)
sequence_Y = np.array(sequence_Y)
print(sequence_X[0])
print(sequence_Y[0])
print(sequence_X.shape)
print(sequence_Y.shape)

from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split(sequence_X, sequence_Y, test_size=0.2)
print(X_train.shape, Y_train.shape)
print(X_test.shape, Y_test.shape)

model = Sequential()
model.add(LSTM(50, input_shape=(30, 1), activation='tanh'))
model.add(Flatten())

# Activation Function이 없는 이유?
# 값을 예측 할 때는 activation function을 사용하면 안됀다. (값 그 자체를 사용해야 하기 때문)
model.add(Dense(units=1))

model.compile(loss='mse', optimizer='adam')
model.summary()

fit_hist = model.fit(X_train, Y_train, epochs=500, validation_data=(X_test, Y_test), shuffle=False)

plt.plot(fit_hist.history['loss'][100:], label='loss')
plt.plot(fit_hist.history['val_loss'][100:], label='val_loss')
plt.legend()
plt.show()

predict = model.predict(X_test)

plt.plot(Y_test[:100], 'bo', label='actual')
plt.plot(predict[:100], 'r*', label='predict')
plt.legend()
plt.show()

last_data = raw_data['2021-10-09':][['Close']]
print(last_data.head())
print(last_data.tail())
print(last_data.info())

last_30 = data.iloc[-30:]
print(last_30.head())
print(last_30.tail())
print(last_30.info())

last_test_data = pd.concat([last_30, last_data])
print(last_test_data.head())
print(last_test_data.tail())
print(last_test_data.info())

scaled_last_test_data = minmaxscaler.transform(last_test_data)
print(scaled_last_test_data.shape)

model.save('./models/stock_close_predict.h5')

sequence_test_x = []
sequence_test_y = []
for i in range(len(scaled_last_test_data)-30):
    x = scaled_last_test_data[i:i+30]
    y = scaled_last_test_data[i+30]
    sequence_test_x.append(x)
    sequence_test_y.append(y)
    if i == 0:
        print(x, '->', y)

sequence_test_x = np.array(sequence_test_x)
sequence_test_y = np.array(sequence_test_y)
print(type(sequence_test_x))
print(type(sequence_test_y))

pred_last = model.predict(sequence_test_x)
plt.plot(sequence_test_y, label='actual')
plt.plot(pred_last, label='predict')
plt.legend()
plt.show()

err_rate = abs(sequence_test_y - pred_last)
plt.plot(err_rate, color='black', label='error rate')
plt.show()

tomorrow_predict = model.predict(scaled_last_test_data[-30:].reshape(1, 30, 1))
print(tomorrow_predict)

tomorrow_predict = minmaxscaler.inverse_transform(pred_last)
print(tomorrow_predict)

tomorrow_predicted_value = minmaxscaler.inverse_transform(tomorrow_predict)
print('%d원'%tomorrow_predicted_value[0][0])

np.append(scaled_last_test_data, tomorrow_predict)

dat_predict = model.predict(scaled_last_test_data[-30:].reshape(1, 30, 1))
print(dat_predict)

dat_predicted_value = minmaxscaler.inverse_transform(dat_predict)
print('%d 원'%dat_predicted_value[0][0])

